<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Sistema Solar UO - Voyagers Edition</title>
<style>
body{margin:0;overflow:hidden;background:black;font-family:Arial}
#info{
  position:absolute;top:10px;left:10px;
  color:white;background:rgba(0,0,0,.6);
  padding:10px;border-radius:6px;z-index:2;max-width:300px
}
#cercano{
  position:absolute;top:50px;left:10px;
  color:#0f0;background:rgba(0,0,0,.6);
  padding:6px;border-radius:6px;font-size:14px;z-index:2;
}
#velControl{
  position:absolute;top:90px;left:10px;
  color:white;background:rgba(0,0,0,.6);
  padding:6px;border-radius:6px;font-size:14px;z-index:2;
}
#timeControl{
  position:absolute;top:130px;left:10px;
  color:#ff0;background:rgba(0,0,0,.6);
  padding:6px;border-radius:6px;font-size:14px;z-index:2;
}
#voyagerInfo{
  position:absolute;top:10px;right:10px;
  color:#0af;background:rgba(0,0,0,.6);
  padding:10px;border-radius:6px;z-index:2;font-size:13px;max-width:250px
}
.planetLabel{
  position:absolute;
  color:white;
  background:rgba(0,0,0,0.7);
  padding:3px 8px;
  border-radius:4px;
  font-size:12px;
  pointer-events:none;
  display:none;
  z-index:1;
  border:1px solid rgba(255,255,255,0.3)
}
#loading{
  position:absolute;top:50%;left:50%;
  transform:translate(-50%,-50%);
  color:white;font-size:18px;
  background:rgba(0,0,0,0.8);
  padding:20px;border-radius:10px;
  z-index:100;text-align:center
}
</style>
</head>
<body>

<div id="info">üéÆ WASD mover ¬∑ Rat√≥n mirar ¬∑ Q/E subir/bajar<br>üîç Rueda: zoom ¬∑ T: mostrar √≥rbitas ¬∑ V: seguir Voyager</div>
<div id="cercano">Cerca de: ‚Äî</div>
<div id="velControl">Velocidad: <span id="velocidadText">10</span> u/s</div>
<div id="timeControl">‚è±Ô∏è Tiempo: <span id="timeScaleText">1x</span> <input type="range" id="timeScale" min="0.1" max="100" value="1" step="0.1" style="width:120px;vertical-align:middle"></div>
<div id="voyagerInfo">üõ∞Ô∏è <strong>Voyagers</strong><br>V1: <span id="v1dist">‚Äî</span> UA<br>V2: <span id="v2dist">‚Äî</span> UA<br><small>Click para cambiar foco</small></div>
<div id="loading">üåå Cargando sistema solar...<br><small>Texturas y Voyagers</small></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

<script>
// ================= ESCENA =================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000011, 0.00002); // Niebla interestelar sutil

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 100000);
camera.position.set(0, 500, 2000);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

// ================= TEXTURAS =================
const loader = new THREE.TextureLoader();
const textures = {
  Sol:"https://i.postimg.cc/zGW5FLW0/sol.png",
  Mercurio:"https://i.postimg.cc/jSqQzfBG/mercurio.png",
  Venus:"https://i.postimg.cc/Znh60vrX/venus.png",
  Tierra:"https://i.postimg.cc/wTp1NdS6/image.png",
  Marte:"https://i.postimg.cc/x8S1LKp4/marte-textura.png",
  J√∫piter:"https://i.postimg.cc/W3mvLxSq/jupiter_textura.png",
  Saturno:"https://i.postimg.cc/T1Wn3qLQ/saturno.png",
  AnillosSaturno:"https://i.postimg.cc/SNXStZ8C/aros.png",
  Urano:"https://i.postimg.cc/dVFNgDp8/urano.png",
  Neptuno:"https://i.postimg.cc/HxFBzLb0/neptuno.png",
  Pluton:"https://i.postimg.cc/sDBswhc5/pluton.png",
  Luna:"https://i.postimg.cc/7hfrGbwg/luna.png"
};

// ================= LUZ =================
const sunLight = new THREE.PointLight(0xffffff, 4, 50000, 2);
sunLight.position.set(0,0,0);
scene.add(sunLight);

// Luz ambiental sutil para rellenar sombras
const ambientLight = new THREE.AmbientLight(0x222233, 0.3);
scene.add(ambientLight);

// Luz direccional para realce de bordes planetarios
const rimLight = new THREE.DirectionalLight(0x4466ff, 0.2);
rimLight.position.set(-1000, 500, -1000);
scene.add(rimLight);

// ================= SOL =================
const sunRadius = 120;
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(sunRadius, 64, 64),
  new THREE.MeshBasicMaterial({map: loader.load(textures.Sol)})
);
scene.add(sun);

// Glow del Sol mejorado
const glowTexture = loader.load("https://threejs.org/examples/textures/lensflare/lensflare0.png");
const glowMat = new THREE.SpriteMaterial({
  map: glowTexture,
  color: 0xffeecc,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  opacity: 0.6
});
const glow = new THREE.Sprite(glowMat);
glow.scale.set(sunRadius*10, sunRadius*10, 1);
glow.position.set(0, 0, 0);
sun.add(glow);

// Capa atmosf√©rica del Sol (resplandor)
const solarAtmosphere = new THREE.Mesh(
  new THREE.SphereGeometry(sunRadius*1.15, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0xffaa44,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  })
);
sun.add(solarAtmosphere);

// Lensflare del Sol (efecto √≥ptico realista)
const lensFlare = new THREE.Lensflare();
lensFlare.position.set(0,0,0);
const lensFlareTexture = loader.load("https://threejs.org/examples/textures/lensflare/lensflare0.png");
lensFlare.addElement(new THREE.LensflareElement(lensFlareTexture, 700, 0, new THREE.Color(0xffddaa)));
lensFlare.addElement(new THREE.LensflareElement(lensFlareTexture, 60, 0.6, new THREE.Color(0xffaa66)));
lensFlare.addElement(new THREE.LensflareElement(lensFlareTexture, 70, 0.7, new THREE.Color(0xff8844)));
scene.add(lensFlare);

// ================= AJUSTE DE C√ÅMARA =================
camera.position.set(0, 500, sunRadius*25);

// ================= ESTRELLAS MEJORADAS =================
(function(){
  const g = new THREE.BufferGeometry();
  const positions = [];
  const colors = [];
  const sizes = [];
  
  const colorPalette = [0xffffff, 0xffeecc, 0xccddff, 0xffccaa, 0xaaccff];
  
  for(let i=0; i<50000; i++){
    const r = 15000 + Math.random()*35000;
    const t = Math.random()*Math.PI*2;
    const p = Math.acos(THREE.MathUtils.randFloatSpread(2));
    
    positions.push(r*Math.sin(p)*Math.cos(t), r*Math.sin(p)*Math.sin(t), r*Math.cos(p));
    
    // Colores estelares variados
    const color = new THREE.Color(colorPalette[Math.floor(Math.random()*colorPalette.length)]);
    colors.push(color.r, color.g, color.b);
    
    // Tama√±os variables con brillo
    sizes.push(Math.random()*1.5 + 0.3);
  }
  
  g.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
  g.setAttribute("color", new THREE.Float32BufferAttribute(colors,3));
  g.setAttribute("size", new THREE.Float32BufferAttribute(sizes,1));
  
  const material = new THREE.PointsMaterial({
    size: 1.2,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    sizeAttenuation: true
  });
  
  const stars = new THREE.Points(g, material);
  scene.add(stars);
  
  // Animaci√≥n sutil de parpadeo estelar
  function twinkleStars(){
    const sizes = g.attributes.size.array;
    for(let i=0; i<sizes.length; i++){
      if(Math.random() > 0.995) sizes[i] = Math.random()*1.2 + 0.4;
    }
    g.attributes.size.needsUpdate = true;
    requestAnimationFrame(twinkleStars);
  }
  twinkleStars();
})();

// ================= POLVO INTERESTELAR =================
(function(){
  const dustGeo = new THREE.BufferGeometry();
  const dustPos = [];
  for(let i=0; i<8000; i++){
    const r = 3000 + Math.random()*20000;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    dustPos.push(
      r*Math.sin(phi)*Math.cos(theta),
      (Math.random()-0.5)*200,
      r*Math.sin(phi)*Math.sin(theta)
    );
  }
  dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
  const dustMat = new THREE.PointsMaterial({
    color: 0x445577,
    size: 0.8,
    transparent: true,
    opacity: 0.4,
    sizeAttenuation: true
  });
  const dust = new THREE.Points(dustGeo, dustMat);
  scene.add(dust);
})();

// ================= CREAR PLANETA =================
function crearPlaneta(nombre,opt){
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(opt.radio,48,48),
    new THREE.MeshStandardMaterial({
      map:loader.load(textures[nombre]),
      roughness: 0.8,
      metalness: 0.1
    })
  );
  mesh.userData = {
    distancia: opt.distancia,
    angulo: Math.random()*Math.PI*2,
    velOrb: opt.velOrb,
    velRot: opt.velRot,
    inclinacion: opt.inclinacion,
    nombre: nombre,
    lunas: [],
    radioReal: opt.radio // para c√°lculos de proximidad
  };
  scene.add(mesh);
  return mesh;
}

// ================= PLANETAS =================
const mercurio = crearPlaneta("Mercurio",{radio:4,distancia:400,velOrb:.00003,velRot:.001,inclinacion:7});
const venus    = crearPlaneta("Venus",{radio:7,distancia:600,velOrb:.000025,velRot:.0008,inclinacion:3});
const tierra   = crearPlaneta("Tierra",{radio:8,distancia:800,velOrb:.00002,velRot:.001,inclinacion:0});
const marte    = crearPlaneta("Marte",{radio:5,distancia:1000,velOrb:.000018,velRot:.0009,inclinacion:1.85});
const jupiter  = crearPlaneta("J√∫piter",{radio:18,distancia:1300,velOrb:.000015,velRot:.002,inclinacion:1.3});
const saturno  = crearPlaneta("Saturno",{radio:16,distancia:1600,velOrb:.000012,velRot:.0015,inclinacion:2.5});
const urano    = crearPlaneta("Urano",{radio:13,distancia:1900,velOrb:.00001,velRot:.0012,inclinacion:0.77});
const neptuno  = crearPlaneta("Neptuno",{radio:13,distancia:2200,velOrb:.000008,velRot:.001,inclinacion:1.77});
const pluton = crearPlaneta("Pluton",{radio:6,distancia:3000,velOrb:.000006,velRot:.0007,inclinacion:17});

// ================= ATM√ìSFERA TERRESTRE (Glow azul) =================
const earthAtmosphere = new THREE.Mesh(
  new THREE.SphereGeometry(8.5, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0x4488ff,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  })
);
tierra.add(earthAtmosphere);

// ================= CREAR LUNAS =================
function crearLuna(planeta,dist,vel,nombre){
  const l = new THREE.Mesh(new THREE.SphereGeometry(2,24,24),
        new THREE.MeshStandardMaterial({map:loader.load(textures.Luna), roughness:0.9}));
  l.userData = {orbita:planeta,distancia:dist,velocidad:vel,angulo:Math.random()*Math.PI*2,nombre:nombre};
  scene.add(l); 
  planeta.userData.lunas.push(l);
  return l;
}

// Lunas principales
crearLuna(tierra,14,0.01,"Luna");
crearLuna(marte,6,0.008,"Fobos");
crearLuna(marte,10,0.006,"Deimos");
crearLuna(jupiter,22,0.006,"Io");
crearLuna(jupiter,28,0.005,"Europa");
crearLuna(jupiter,34,0.004,"Ganimedes");
crearLuna(jupiter,40,0.003,"Calisto");
crearLuna(saturno,22,0.004,"Tit√°n");
crearLuna(saturno,28,0.0035,"Rea");
crearLuna(saturno,34,0.003,"J√°peto");
crearLuna(saturno,40,0.0025,"Dione");
crearLuna(urano,18,0.003,"Miranda");
crearLuna(urano,22,0.0028,"Ariel");
crearLuna(urano,26,0.0025,"Umbriel");
crearLuna(urano,30,0.0022,"Titania");
crearLuna(urano,34,0.002,"Ober√≥n");
crearLuna(neptuno,18,0.0025,"Trit√≥n");
crearLuna(neptuno,24,0.0022,"Nereida");
crearLuna(pluton,8,0.0018,"Caronte");
crearLuna(pluton,12,0.0015,"Nix");
crearLuna(pluton,16,0.0013,"Hidra");

// ================= ANILLOS SATURNO =================
const ringSatGeo = new THREE.RingGeometry(18, 50, 128);
const ringSatMat = new THREE.MeshBasicMaterial({
  map:loader.load(textures.AnillosSaturno), 
  side:THREE.DoubleSide, 
  transparent:true,
  opacity: 0.9
});
const ringSat = new THREE.Mesh(ringSatGeo, ringSatMat);
ringSat.rotation.x = Math.PI/2 + 0.3;
ringSat.rotation.z = 0.45;
scene.add(ringSat);

// ================= CINTUR√ìN DE ASTEROIDES PRINCIPAL (Marte-J√∫piter) üÜï =================
(function(){
  const asteroidBelt = new THREE.Group();
  const numAst = 3000;
  
  for(let i=0; i<numAst; i++){
    const radio = Math.random()*0.8 + 0.2;
    const geo = new THREE.DodecahedronGeometry(radio, 0);
    const mat = new THREE.MeshStandardMaterial({
      color: new THREE.Color().setHSL(0.08, 0.3, 0.3 + Math.random()*0.2),
      roughness: 0.9,
      metalness: 0.1
    });
    const ast = new THREE.Mesh(geo, mat);

    const ang = Math.random()*Math.PI*2;
    const dist = 1050 + Math.random()*180; // Entre Marte (1000) y J√∫piter (1300)
    const yPos = THREE.MathUtils.randFloatSpread(30);
    ast.position.set(Math.cos(ang)*dist, yPos, Math.sin(ang)*dist);
    
    // Rotaci√≥n aleatoria
    ast.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
    
    asteroidBelt.add(ast);
  }
  scene.add(asteroidBelt);

  function animAsteroidBelt(){
    asteroidBelt.children.forEach(a=>{
      const angVel = 0.000015 + Math.random()*0.000008;
      const x = a.position.x;
      const z = a.position.z;
      const dist = Math.sqrt(x*x + z*z);
      const ang = Math.atan2(z, x) + angVel * timeScale;
      a.position.x = Math.cos(ang)*dist;
      a.position.z = Math.sin(ang)*dist;
      a.rotation.y += 0.001 * timeScale;
    });
    requestAnimationFrame(animAsteroidBelt);
  }
  animAsteroidBelt();
})();

// ================= CINTUR√ìN DE KUIPER (NEPTUNO-PLUT√ìN) - Original mejorado =================
(function(){
  const kuiperGroup = new THREE.Group();
  const numKuiper = 5000;
  for(let i=0; i<numKuiper; i++){
    const radio = Math.random()*1 + 0.3;
    const geo = new THREE.IcosahedronGeometry(radio, 0);
    const mat = new THREE.MeshStandardMaterial({
      color: new THREE.Color().setHSL(0.6, 0.1, 0.4 + Math.random()*0.2),
      roughness: 0.95
    });
    const obj = new THREE.Mesh(geo, mat);

    const ang = Math.random()*Math.PI*2;
    const dist = 2400 + Math.random()*600;
    const yPos = THREE.MathUtils.randFloatSpread(60);
    obj.position.set(Math.cos(ang)*dist, yPos, Math.sin(ang)*dist);
    obj.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
    kuiperGroup.add(obj);
  }
  scene.add(kuiperGroup);

  function animKuiper(){
    kuiperGroup.children.forEach(a=>{
      const angVel = 0.000005 + Math.random()*0.000005;
      const x = a.position.x, z = a.position.z;
      const dist = Math.sqrt(x*x + z*z);
      const ang = Math.atan2(z, x) + angVel * timeScale;
      a.position.x = Math.cos(ang)*dist;
      a.position.z = Math.sin(ang)*dist;
      a.rotation.y += 0.0003 * timeScale;
    });
    requestAnimationFrame(animKuiper);
  }
  animKuiper();
})();

// ================= VOYAGERS üöÄüÜï =================
function crearVoyager(nombre, color, posInicial, trayectoria){
  // Modelo simplificado de Voyager: cuerpo + antena + paneles
  const group = new THREE.Group();
  
  // Cuerpo principal
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1.2, 0.6, 0.8),
    new THREE.MeshStandardMaterial({color: color, metalness:0.8, roughness:0.3})
  );
  group.add(body);
  
  // Antena parab√≥lica
  const dish = new THREE.Mesh(
    new THREE.CylinderGeometry(0.8, 0.8, 0.1, 32),
    new THREE.MeshStandardMaterial({color: 0xcccccc, metalness:0.9})
  );
  dish.rotation.x = Math.PI/2;
  dish.position.z = -0.7;
  group.add(dish);
  
  // Brazo de instrumentos
  const boom = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
    new THREE.MeshStandardMaterial({color: 0x444444})
  );
  boom.rotation.z = Math.PI/4;
  boom.position.set(0.8, 0.3, 0.2);
  group.add(boom);
  
  // Paneles RTG (generadores)
  const rtg = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.15, 0.8, 16),
    new THREE.MeshStandardMaterial({color: 0x332211, roughness:0.7})
  );
  rtg.rotation.x = Math.PI/2;
  rtg.position.set(-0.9, 0, 0);
  group.add(rtg);
  
  // Luz de navegaci√≥n (parpadeante)
  const navLight = new THREE.PointLight(0x00ff88, 0.5, 10, 2);
  navLight.position.set(0, 0.5, 1);
  group.add(navLight);
  
  // Trail de part√≠culas (estela)
  const trailGeo = new THREE.BufferGeometry();
  const trailPoints = [];
  for(let i=0; i<50; i++) trailPoints.push(new THREE.Vector3());
  trailGeo.setFromPoints(trailPoints);
  const trailMat = new THREE.LineBasicMaterial({color: color, transparent:true, opacity:0.6});
  const trail = new THREE.Line(trailGeo, trailMat);
  group.add(trail);
  
  group.userData = {
    nombre: nombre,
    posicion: new THREE.Vector3().copy(posInicial),
    trayectoria: trayectoria,
    progreso: 0,
    velocidad: 0.0008 + Math.random()*0.0003,
    trail: trail,
    trailPoints: trailPoints,
    navLight: navLight
  };
  
  group.position.copy(posInicial);
  scene.add(group);
  return group;
}

// Trayectorias hiperb√≥licas realistas (simplificadas)
const voyager1 = crearVoyager(
  "Voyager 1", 
  0xffaa44, 
  new THREE.Vector3(800, 50, 0), // Lanzado desde zona interior
  {tipo: "escape", direccion: new THREE.Vector3(0.3, 0.8, 0.5).normalize(), curva: 0.02}
);

const voyager2 = crearVoyager(
  "Voyager 2", 
  0x44aaff, 
  new THREE.Vector3(-600, -30, 200),
  {tipo: "escape", direccion: new THREE.Vector3(-0.6, 0.4, -0.7).normalize(), curva: 0.015}
);

// Funci√≥n para actualizar posici√≥n de Voyagers
function actualizarVoyager(voyager){
  const data = voyager.userData;
  data.progreso += data.velocidad * timeScale;
  
  // Movimiento con ligera curva gravitacional
  const moveDir = data.trayectoria.direccion.clone();
  // Efecto de "slingshot" cerca del Sol
  const distToSun = voyager.position.distanceTo(sun.position);
  if(distToSun < 1500){
    const pull = sun.position.clone().sub(voyager.position).normalize();
    moveDir.add(pull.multiplyScalar(0.02 * (1500/distToSun)));
  }
  moveDir.normalize();
  
  voyager.position.add(moveDir.multiplyScalar(0.3 * timeScale));
  
  // Actualizar estela
  data.trailPoints.unshift(voyager.position.clone());
  data.trailPoints.pop();
  data.trail.geometry.setFromPoints(data.trailPoints);
  
  // Parpadeo de luz de navegaci√≥n
  data.navLight.intensity = 0.3 + Math.sin(Date.now()*0.01)*0.2;
  
  // Rotaci√≥n sutil
  voyager.rotation.y += 0.002 * timeScale;
  voyager.rotation.z = Math.sin(Date.now()*0.001)*0.1;
}

// ================= ETIQUETAS DE PLANETAS üÜï =================
const planetLabels = {};
const labelContainer = document.createElement('div');
labelContainer.id = 'labels';
document.body.appendChild(labelContainer);

function crearEtiquetaPlaneta(mesh, nombre){
  const div = document.createElement('div');
  div.className = 'planetLabel';
  div.textContent = nombre;
  labelContainer.appendChild(div);
  planetLabels[nombre] = {element: div, mesh: mesh};
}

// Crear etiquetas para todos los objetos
[
  {m: sol, n: "‚òÄÔ∏è Sol"},
  {m: mercurio, n: "‚òø Mercurio"},
  {m: venus, n: "‚ôÄ Venus"},
  {m: tierra, n: "üåç Tierra"},
  {m: marte, n: "‚ôÇ Marte"},
  {m: jupiter, n: "‚ôÉ J√∫piter"},
  {m: saturno, n: "‚ôÑ Saturno + Anillos"},
  {m: urano, n: "‚ôÖ Urano"},
  {m: neptuno, n: "‚ôÜ Neptuno"},
  {m: pluton, n: "‚ö≥ Plut√≥n"}
].forEach(obj => crearEtiquetaPlaneta(obj.m, obj.n));

// Lunas con etiquetas tambi√©n
["Luna","Fobos","Deimos","Io","Europa","Ganimedes","Calisto","Tit√°n","Trit√≥n","Caronte"].forEach(nombreLuna => {
  // Buscamos la luna en escena por nombre (simplificado)
  scene.traverse(obj => {
    if(obj.userData && obj.userData.nombre === nombreLuna){
      crearEtiquetaPlaneta(obj, `üåô ${nombreLuna}`);
    }
  });
});

function actualizarEtiquetas(){
  Object.values(planetLabels).forEach(label => {
    const {element, mesh} = label;
    // Proyectar posici√≥n 3D a 2D
    const vector = mesh.position.clone();
    vector.project(camera);
    
    const x = (vector.x * 0.5 + 0.5) * innerWidth;
    const y = (-(vector.y * 0.5) + 0.5) * innerHeight;
    
    // Mostrar solo si est√° cerca y en pantalla
    const dist = camera.position.distanceTo(mesh.position);
    const visible = dist < (mesh.userData?.radioReal || 20) * 30 && 
                   vector.z < 1 && 
                   x > 50 && x < innerWidth-50 && 
                   y > 50 && y < innerHeight-50;
    
    element.style.display = visible ? 'block' : 'none';
    if(visible){
      element.style.left = `${x}px`;
      element.style.top = `${y}px`;
      // Escalar texto con distancia
      const scale = Math.max(0.7, Math.min(1.5, 2000/dist));
      element.style.transform = `translate(-50%, -100%) scale(${scale})`;
    }
  });
}

// ================= CONTROLES =================
const controls = new THREE.PointerLockControls(camera, document.body);
document.body.addEventListener("click", ()=>{
  if(!controls.isLocked) controls.lock();
});
const move={f:false,b:false,l:false,r:false,u:false,d:false};

let velocidad = 10;
const velocidadText = document.getElementById("velocidadText");

let timeScale = 1; // Escala de tiempo (1x = velocidad normal)
const timeScaleText = document.getElementById("timeScaleText");
const timeScaleInput = document.getElementById("timeScale");

timeScaleInput.addEventListener('input', (e) => {
  timeScale = parseFloat(e.target.value);
  timeScaleText.textContent = timeScale + 'x';
});

document.addEventListener("keydown", e=>{
  if(e.code==="KeyW")move.f=true;
  if(e.code==="KeyS")move.b=true;
  if(e.code==="KeyA")move.l=true;
  if(e.code==="KeyD")move.r=true;
  if(e.code==="KeyE")move.u=true;
  if(e.code==="KeyQ")move.d=true;
  if(e.code==="ArrowUp"){ velocidad+=2; velocidadText.textContent = velocidad; }
  if(e.code==="ArrowDown"){ velocidad=Math.max(1,velocidad-2); velocidadText.textContent = velocidad; }
  if(e.code==="KeyT"){ toggleOrbitas(); } // Mostrar/ocultar √≥rbitas
  if(e.code==="KeyV"){ seguirVoyager(); } // Cambiar foco entre Voyagers
});

document.addEventListener("keyup", e=>{
  if(e.code==="KeyW")move.f=false;
  if(e.code==="KeyS")move.b=false;
  if(e.code==="KeyA")move.l=false;
  if(e.code==="KeyD")move.r=false;
  if(e.code==="KeyE")move.u=false;
  if(e.code==="KeyQ")move.d=false;
});

// ================= √ìRBITAS VISUALES (opcional) üÜï =================
let orbitasVisibles = false;
const orbitLines = {};

function crearOrbita(distancia, inclinacion){
  const curve = new THREE.EllipseCurve(
    0, 0,            // centro
    distancia, distancia, // radios
    0, 2*Math.PI,    // √°ngulos
    false,           // horario
    0                // rotaci√≥n
  );
  
  const points = curve.getPoints(128);
  const geometry = new THREE.BufferGeometry().setFromPoints(
    points.map(p => new THREE.Vector3(p.x, 0, p.y).applyAxisAngle(new THREE.Vector3(1,0,0), inclinacion * Math.PI/180))
  );
  
  const material = new THREE.LineBasicMaterial({ 
    color: 0x4466aa, 
    transparent: true, 
    opacity: 0.25,
    linewidth: 1
  });
  
  return new THREE.Line(geometry, material);
}

// Crear l√≠neas de √≥rbita para planetas principales
[mercurio,venus,tierra,marte,jupiter,saturno,urano,neptuno,pluton].forEach(p => {
  const orbit = crearOrbita(p.userData.distancia, p.userData.inclinacion);
  orbit.userData = {planeta: p};
  scene.add(orbit);
  orbit.visible = false;
  orbitLines[p.userData.nombre] = orbit;
});

function toggleOrbitas(){
  orbitasVisibles = !orbitasVisibles;
  Object.values(orbitLines).forEach(orbit => orbit.visible = orbitasVisibles);
}

// ================= SEGUIR VOYAGER üÜï =================
let siguiendoVoyager = null;
function seguirVoyager(){
  if(siguiendoVoyager === null){
    siguiendoVoyager = voyager1;
  } else if(siguiendoVoyager === voyager1){
    siguiendoVoyager = voyager2;
  } else {
    siguiendoVoyager = null;
  }
  
  if(siguiendoVoyager){
    // Posicionar c√°mara detr√°s del Voyager
    const offset = new THREE.Vector3(0, 5, -25);
    offset.applyQuaternion(siguiendoVoyager.quaternion);
    camera.position.copy(siguiendoVoyager.position).add(offset);
    camera.lookAt(siguiendoVoyager.position);
  }
}

// ================= PLANETA M√ÅS CERCANO + INFO MEJORADA =================
const cercanoDiv = document.getElementById("cercano");
const v1distEl = document.getElementById("v1dist");
const v2distEl = document.getElementById("v2dist");

function actualizarCercano(){
  const todos=[mercurio,venus,tierra,marte,jupiter,saturno,urano,neptuno,pluton];
  let masCercano = {nombre:"‚Äî", dist:Infinity, objeto:null};
  
  // Verificar planetas
  todos.forEach(p=>{
    const d = camera.position.distanceTo(p.position);
    if(d < masCercano.dist){ 
      masCercano = {nombre:p.userData.nombre, dist:d, objeto:p}; 
    }
    p.userData.lunas.forEach(l=>{
      const dl = camera.position.distanceTo(l.position);
      if(dl < masCercano.dist){ 
        masCercano = {nombre:l.userData.nombre, dist:dl, objeto:l}; 
      }
    });
  });
  
  // Verificar Voyagers
  [voyager1, voyager2].forEach(v => {
    const dv = camera.position.distanceTo(v.position);
    if(dv < masCercano.dist){
      masCercano = {nombre: v.userData.nombre, dist: dv, objeto: v};
    }
  });
  
  cercanoDiv.textContent = `Cerca de: ${masCercano.nombre} (${masCercano.dist.toFixed(0)} u)`;
  
  // Actualizar distancias de Voyagers en panel
  v1distEl.textContent = (voyager1.position.length() / 800).toFixed(2); // Escala a UA aproximada
  v2distEl.textContent = (voyager2.position.length() / 800).toFixed(2);
  
  // Mostrar info adicional si est√° muy cerca
  if(masCercano.dist < 200 && masCercano.objeto?.userData?.nombre){
    const nombre = masCercano.objeto.userData.nombre;
    if(!cercanoDiv.textContent.includes('üî¨')){
      cercanoDiv.textContent += ` üî¨`;
    }
  }
}

// ================= ANIMACI√ìN =================
function animate(){
  requestAnimationFrame(animate);

  // Movimiento de c√°mara
  if(move.f)controls.moveForward(velocidad);
  if(move.b)controls.moveForward(-velocidad);
  if(move.l)controls.moveRight(-velocidad);
  if(move.r)controls.moveRight(velocidad);
  if(move.u)camera.position.y+=velocidad;
  if(move.d)camera.position.y-=velocidad;

  // Si siguiendo un Voyager, la c√°mara lo sigue suavemente
  if(siguiendoVoyager && controls.isLocked){
    const offset = new THREE.Vector3(0, 8, -35);
    offset.applyQuaternion(siguiendoVoyager.quaternion);
    const targetPos = siguiendoVoyager.position.clone().add(offset);
    camera.position.lerp(targetPos, 0.05);
    camera.lookAt(siguiendoVoyager.position);
  }

  // Actualizar planetas
  [mercurio,venus,tierra,marte,jupiter,saturno,urano,neptuno,pluton].forEach(p=>{
    p.userData.angulo += p.userData.velOrb * timeScale;
    p.position.x = Math.cos(p.userData.angulo)*p.userData.distancia;
    p.position.z = Math.sin(p.userData.angulo)*p.userData.distancia;
    p.rotation.y += p.userData.velRot * timeScale;
    p.rotation.z = p.userData.inclinacion * Math.PI/180;
    
    // Actualizar √≥rbita visual si est√° activa
    if(orbitLines[p.userData.nombre] && orbitasVisibles){
      orbitLines[p.userData.nombre].position.copy(p.position);
    }
    
    p.userData.lunas.forEach(l=>{
      l.userData.angulo += l.userData.velocidad * timeScale;
      l.position.x = p.position.x + Math.cos(l.userData.angulo)*l.userData.distancia;
      l.position.z = p.position.z + Math.sin(l.userData.angulo)*l.userData.distancia;
    });
  });

  // Anillos de Saturno siguen al planeta
  ringSat.position.copy(saturno.position);
  
  // Actualizar Voyagers üöÄ
  actualizarVoyager(voyager1);
  actualizarVoyager(voyager2);
  
  // Actualizar etiquetas de nombres
  actualizarEtiquetas();
  
  // Actualizar info UI
  actualizarCercano();
  
  // Ocultar loading cuando todo est√© listo
  const loading = document.getElementById('loading');
  if(loading && Object.keys(textures).every(k => loader.load(textures[k]).image)){
    loading.style.display = 'none';
  }
  
  renderer.render(scene,camera);
}
animate();

// ================= RESIZE =================
addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

// ================= CLICK EN VOYAGERS PARA SEGUIRLOS üÜï =================
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

document.addEventListener('click', (event) => {
  if(!controls.isLocked) return;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  
  // Verificar click en Voyagers
  const voyagers = [voyager1, voyager2];
  const intersects = raycaster.intersectObjects(voyagers, true);
  
  if(intersects.length > 0){
    const clicked = intersects[0].object.parent; // El grupo
    if(siguiendoVoyager === clicked){
      siguiendoVoyager = null; // Dejar de seguir
    } else {
      siguiendoVoyager = clicked;
    }
  }
});

// ================= INSTRUCCIONES ADICIONALES AL CARGAR =================
setTimeout(() => {
  document.getElementById('loading').innerHTML = 
    '‚úÖ Sistema cargado<br><small>Click para comenzar ‚Ä¢ Presiona V para seguir Voyagers</small>';
}, 2000);
</script>
</body>
</html>
